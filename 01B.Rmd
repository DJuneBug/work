---
title: "Efficient R Programming"
author: "Mingyang Lu"
date: "10/12/2021"
output: 
  github_document:
    toc: true
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

So far, the basics of R are introduced. Writing R code is not difficult, in fact quite intuitive. However, using R efficiently is not easy. R scripts are interpretive, thus R can't compete with compiled languages, such as C and Fortran, in terms of computational efficiency. That becomes especially important for numerical analyses. Interestingly, many approaches we learn from compiled languages are not necessarily applicable to R programming. Here, I will introduce a few techniques to make R codes more efficient. I highly recommend the online book  [Efficient R programming](https://csgillespie.github.io/efficientR/) for details of this topic.
For example, one should use factors when possible, as they are good for statistical analysis. A general principle is to avoid computation in R scripts. A good practice of R programming is to avoid intensive/iterative calculations directly in R code. The goal is to do these calculations with more efficient functions, typically written in C or Fortran.

## Avoid growing vectors
The following code is extremely slow for large n.
```{r}
n = 10
v = c()
for(i in seq_len(n)){
  v = c(v, i**2)
}
v
```
A better way creates an array of final length first.
```{r}
n = 10
v = numeric(n)
for(i in seq_len(n)) {
  v[i] = i**2
}
v
```

## Vectorize codes
An even better appraoch is the following. It uses vector operations instead.
```{r}
v = seq_len(n)
v = v*v
v
```

Iteration is commonly used in programming. Unfortunately, iteration, *e.g.*, using a For Loop, is very slow in R. For example, the following code calculates the mean and standard deviation (SD) of a series of numbers. 
``` {r}
my_sum = 0
my_sum2 = 0
num = 100
for (i in seq_len(num)) {
  my_sum = my_sum + i
  my_sum2 = my_sum2 + i*i
}
my_mean = my_sum/num
my_sd = sqrt(my_sum2/num - my_mean**2)
my_mean; my_sd
```
While the above code is typical for C or Fortran, a better approach for R is to use vector operations. 
```{r}
v = seq_len(num)
my_mean = mean(v)
my_variance = mean(v*v)
my_sd = sqrt(my_variance - my_mean**2)
my_mean; my_sd
```
Apply can be used to perform operations for columns (or rows) of a matrix.
```{r}
mat = matrix(rnorm(16), nrow = 4)    # generating a random matrix of 4 x 4
means = apply(mat, 2, mean)
means2 = apply(mat*mat, 2, mean)
sd = sqrt(means2 - means*means)
sd
```

## Byte compile package
Any function can be compiled into byte code for an easy performance boost.
```{r}
library(compiler)
my_sd =  function(x) {   # define the function
  my_mean = mean(x)
  my_mean2 = mean(x*x)
  sqrt(my_mean2 - my_mean**2)
}
cmp_sd = cmpfun(my_sd)   # compile it to byte code
cmp_sd(seq_len(100))   # same calculations as a previous example, but with compiled function
apply(mat, 2, cmp_sd)  # apply to a matrix 

```

## Use C/Fortran codes
Many R packages are written in a compiled language. It is important to use them when possible. It is also feasible to write functions in C, C++, or Fortran, and call these functions from R.
Here is an example of Fortran subroutines, provided in the file "extra/src/sub_cal_sd.f90". Note that only integer, double precision and logical arguments are allowed in Fortran-R interface approach. 
```
subroutine cal_sd(n,x,sd)
  integer,intent(in) :: n
  double precision, intent(in) :: x(n)
  double precision, intent(out) :: sd
  integer :: i
  double precision :: mean, mean2
  mean = 0.d0
  mean2 = 0.d0
  do i = 1, n
    mean = mean + x(i)
    mean2 = mean2 + x(i)**2
  end do
  mean = mean/n
  mean2 = mean2/n
  sd = sqrt(mean2 - mean**2)
end subroutine cal_sd
```
The Fortran code needs to be first compiled into a .so file. This needs to be done in command line with a fortran compiler (gfortran from gcc).
```
gfortran -fpic -shared extra/src/sub_cal_sd.f90 -o extra/src/sub_cal_sd.so
```
Then, in R load the shared library
```{r}
dyn.load("extra/src/sub_cal_sd.so")
```
cal_sd can be called in R below. The arguments of the Fortran subroutines can be found in the output list.
```{r}
n = 100
v = seq_len(n)
my_sd = 0.0
results = .Fortran("cal_sd",as.integer(n),as.double(v), my_sd)
results             # [[3]] outputs the sd 
```
To make it even more convenient, one can write a R wrapper.
``` {r}
 my_sd_R <- function(x) {
   if (!is.numeric(x))
           stop("argument x must be numeric")
   my_sd = 0.0
   results =  .Fortran("cal_sd", as.integer(length(x)), as.double(x), my_sd)
   return(results[[3]])
 }
my_sd_R(seq_len(100))
```
More details can be found in [this page](http://users.stat.umn.edu/~geyer/rc/).

## Parallelization
Lastly, parallelization is another way to improve the performance of R. If simple parallelization is needed, it's pretty simple with Apply functions. Simply setup the desired calculations in a list. Instead of using lapply, use mclapply and specify the number of cores in use. As demonstrated below, the code with parallelization is about three times faster.
```{r}
library(parallel)   # load the parallel library
numCores = detectCores()     # the number of available cores 
tests = seq(1, 10000)
my_test <- function(test_id) {
  v = rnorm(5000)
  return(my_sd_R(v))
}
system.time({      # no parallel
  results = lapply(tests, my_test)
})
system.time({      # with parallel
  results = mclapply(tests, my_test, mc.cores = numCores)
})
```
For additional read, please [check this page](https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html)
