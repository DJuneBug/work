---
title: "Introduction to R Programming"
author: "Mingyang Lu"
date: "10/12/2021"
output: 
  github_document:
    toc: true
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Why Using R?
R is a programming language designed for statistical computing and graphics. Unlike a compiled language, such as C and Fortran, R is typically used as an interpreted language. There are several reasons why I choose R here.

* R is simple to use. If you have some experience with any other programming language, it should be pretty easy to learn R.

* R comes with an interactive environment for programming. Many users also use [RStudio](https://www.rstudio.com) for R. It provides an integrated environment for coding and scripting and a user-friendly Graphic User Interface (GUI), very similar to Matlab. [Here is an article comparing R and Matlab.](https://hackr.io/blog/r-vs-matlab)  

* R is cross-platform. Both R and RStudio are available in Windows, Mac, and Linux. 

* Many R packages have been developed and are freely accessible for statistical analyses and biomedical research. R packages can usually be found via (1) [Github](https://github.com); (2) The Comprehensive R Archive Network ([CRAN](https://cran.r-project.org)); (3) [BioConductor](https://www.bioconductor.org) for bioinformatics.

* It is not difficult to develop R packages. R also provides interface for other languages, such as C++ and Fortran, for computational efficiency. 

* R packages can also be easily converted into interactive web app using [Shiny](https://shiny.rstudio.com).

To get started, one needs to download and install R and RStudio from the following websites:  [CRAN](https://cran.r-project.org) and [RStudio](https://www.rstudio.com/). I recommend R version 3.6.3 for this tutorial. 

From the R Console, type the following command to get help.

```{r}
help(runif)     # show documentation for the topic -- runif in this example
```

## A crash course of R
I will not provide a detailed R tutorial, as they are already available. I recommend the following resources for learning R.

* [An Introduction to R](https://cran.r-project.org/doc/manuals/r-release/R-intro.html) from [CRAN](https://cran.r-project.org)

* [R & Bioconductor Manual](http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual) by Thomas Girke at UC Riverside

* [Efficient R programming](https://csgillespie.github.io/efficientR/) by Colin Gillespie & Robin Lovelace

Here, I will provide a brief overview of R syntax and highlight a few R's unique features. 

#### Typical data types & math operations
```{r}
a = 10 + 3.14    # integer, real number; assignment to a
a*a # a multiplies a
a**2 # square of a, which gives the same value as the previous one
b = 3.0 + 4.0i  # complex number; assignment to b
Mod(b) # The modulus of b
c = (3 + 4 == 7)   # logical; c is TRUE
!c   # not c, which is FALSE
d = "Monday"  # character
class(d)  # showing the data type of d
nchar(d)  # number of characters in a string
```
#### Vectors
```{r}
vec = c("Man","Woman","Woman","Man","Woman")   # a vector of characters
length(vec) #length of a vector
vec == "Woman" # logic values comparing each element to "Woman"
which(vec == "Woman") # identifying the indices of the elements being "Woman"
```
#### Factors
Factor type is an important data type in R. It is commonly used to represent categorical data. 
```{r}
vec_factor = as.factor(vec)   # converting the character vector to a factor vector
class(vec);class(vec_factor)  # checking the data types
levels(vec_factor); nlevels(vec_factor)  # levels and the number of levels
```
#### If statement
```{r}
a = 0
if(a == 1){   # conditions
  print("a equals to 1")
} else {
  print("a is not 1")
}
```
#### For loops
```{r}
for (i in 1:5) print(i)   # version 1
```

```{r}
for (i in seq_len(5)) print(i)   # version 2
```

```{r}
v = c(1,2,5,7)
for (i in v){
  print(i)   # version 3
}
```

#### While statement
```{r}
i = 0
while(i < 5){
  i = i + 2
  print(i)
}
```

#### Apply
Another unique feature in R. Apply performs a function iteratively through an array or matrix. It's usually more efficient than a for-loop. Syntax: apply(X, MARGIN, FUN). Here, X is an array or matrix. MARGIN=1 performs the specified function by rows, MARGIN=2 by columns. FUN is the function to apply. 
```{r}
mat = matrix(rnorm(16), nrow = 4)    # generating a random matrix of 4 x 4
mat
apply(mat, 1, sum)   # row sum
rowSums(mat)   # An alternative way to do row sum
apply(mat, 2, sum)   # column sum
colSums(mat)  # An alternative way to do column sum
```
There are other apply-like functions, such as lappy, sappy, tapply, *etc.* [Check here for more details.](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family)

#### Functions
```{r}
myfunction <- function(x) {    # a simple function to perform x square
  x*x
}
b = myfunction(4)
print(paste0("b = ",b))
```

#### List
Lists can contain elements of different types. 
```{r}
my_list = list("a", c(1,2,3), FALSE, 3.14)  # Defining a new list
my_list[[1]]   # the first element
my_list[[2]]   # the second element
names(my_list) = c("letters", "array", "TF", "pi")  # naming list elements
my_list$TF   # retrieve elements by names
my_vector = unlist(my_list)   # convert the list to a vector
my_vector
```

#### Data frame
Data frame is widely used in R. It's similar to a matrix but allows mixed data types in it.
```{r}
my_data = data.frame(
          id = c(1:5),
          atom = c("N","CA","CB","C","O"),
          mass = c(14, 12, 12, 12, 16),
          size = c(1.2, 1.4, 1.4, 1.4, 1.1),
          stringsAsFactors = F
)
print(my_data)
colnames(my_data)
str(my_data)      # get the structure 
my_data$mass      # retrieve a column
my_data$backbone = c(T, T, F, T, T)   # add a column
print(my_data)
my_data = rbind(my_data, c(6, "S", 32, 1.6, F))   # add a row
print(my_data)
```

#### Input/output
```{r}
save(my_data,file = "my_data.Rdata")    # save the data frame my_data to file
saveRDS(my_data, file = "my_data.RDS")  # save my_data to an RDS file
load("my_data.Rdata")   # read data from an Rdata file; my_data, if exist, would be overwritten
my_data2 = readRDS("my_data.RDS")   # read data from an RDS file, assign it to another variable
```

#### Package
The following code works to install/remove packages (not in the R markdown format to avoid adding/removing packages)
```
if(! "umap" %in% rownames(installed.packages())) {      # check if the package exists
  install.packages("umap")   # if not, install "umap"
}
library("umap")    # load the umap library
help(umap)
remove.packages("umap")    # remove it ...
```

#### Basic plotting
``` {r}
x = seq_len(5)
y = x**2
plot(x, y)       # plot points
curve(x**2)      # plot f(x) = x*x
y = data.frame(xvalues = rnorm(1000), yvalues = rnorm(1000))    # 1000 random points in 2D
plot(y$xvalues, y$yvalues)     # scatter plot
library(ggplot2)
ggplot(y, aes(x = xvalues, y = yvalues)) +    # density map
  stat_density2d(aes(fill = ..density..), geom = "raster", contour = FALSE)
``` 

## A few notes
The previous section highlights the basic usage of R. Please refer to "[An Introduction to R](https://cran.r-project.org/doc/manuals/r-release/R-intro.html)" and [R & Bioconductor Manual](http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual) for more details. In the following, I will emphasize a few R features that new learners may overlook or be confused.

#### Factor vs. string
Factors may look similar to Strings, but they are very different in R scripting. What makes things worse is that, in R version before 4.0, stringsAsFactors = TRUE by default. That means, for R funtionality using the parameter stringsAsFactors, any string would be interpreted as a factor . However, in R version 4.0 or later, the default stringsAsFactors = FALSE. If a package is developed for R before v4.0 and by assuming default treatment of strings (as factors), the same package may not work properly for R v.4.0 or later. A good practice for R programming is (1) Use R version 3.6.3 if many legacy R packages are required; (2) always specify how string would be treated. Here is an example to create a data frame containing characters/strings.

```{r}
my_data = data.frame(
          id = c(1:5),
          atom = c("N","CA","CB","C","O"),
          mass = c(14, 12, 12, 12, 16),
          size = c(1.2, 1.4, 1.4, 1.4, 1.1)
)
print(my_data)
class(my_data$atom)   # factor if R version < 4.0; character if R version >=4.0
my_data = data.frame(
          id = c(1:5),
          atom = c("N","CA","CB","C","O"),
          mass = c(14, 12, 12, 12, 16),
          size = c(1.2, 1.4, 1.4, 1.4, 1.1),
          stringsAsFactors = F
)

class(my_data$atom)  # always character type
```
Here is an example to read a table from a file.
```{r}
write.table(my_data, file = "my_data.txt", quote = F, sep="\t", row.names = F) #The table is saved to a file
data_read = read.table("my_data.txt", header = T, sep = "\t")   #Read the table from the saved file
class(data_read$atom)   # factor if R version < 4.0; character if R version >=4.0
data_read = read.table("my_data.txt", header = T, sep = "\t", as.is = T)   # as.is = T reads strings as characters
class(data_read$atom)
```

#### Data frame vs. matrix
Matrix is more suitable for linear algebra analysis; while data frame is good to save heterogeneous data and ideal for statistics analysis, plotting, *etc.* Sometimes, data can be saved as either a data frame or a matrix. It is important to be aware of the data type, so that appropriate functions/operators are applied. Refer to [the following article](https://www.geeksforgeeks.org/matrix-vs-dataframe-in-r/) for the comparison of matrix and data frame.
[Basic plotting] shows an example of plotting with data frame. Here is an example of linear regression with data frame.
```{r}
plot(my_data$mass, my_data$size, xlab = "Size", ylab = "Mass")    # size vs. mass in my_data
model = lm(size~mass, data = my_data)   # linear regression
abline(model)   # add fited line
summary(model)   # summary of the linear model

```
#### List vs. vector
Lists are recursive type of vectors -- lists can have values of different types. A data frame is a list where column elements have the same data type. In the above-mentioned linear regression example, model is a list containing results of the linear model.
```{r}
str(model)   # show the structure of the list
```
Below, mean value is computed for each column of the matrix using lapply. 
```{r}
means = lapply(mat, mean)    # this doesn't work
length(means)
mat_list =  lapply(seq_len(ncol(mat)), function(i) mat[,i])  # convert to a list by column vectors
means = lapply(mat_list,mean)  # calculate means for a list
means
means2 = colMeans(mat)   # an alternative way to compute column means
means2
```

## Efficient R programming
So far, the basics of R are introduced. Writing R code is not difficult, in fact quite intuitive. However, using R efficiently is not easy. R scripts are interpretive, thus R can't compete with compiled languages, such as C and Fortran, in terms of computational efficiency. That becomes especially important for numerical analyses. Interestingly, many approaches we learn from compiled languages are not necessarily applicable to R programming. Here, I will introduce a few techniques to make R codes more efficient. I highly recommend the online book  [Efficient R programming](https://csgillespie.github.io/efficientR/) for details of this topic.
For example, one should use factors when possible, as they are good for statistical analysis. A general principle is to avoid computation in R scripts. A good practice of R programming is to avoid intensive/iterative calculations directly in R code. The goal is to do these calculations with more efficient functions, typically written in C or Fortran.

#### Avoid growing vectors
The following code is extremely slow for large n.
```{r}
n = 10
v = c()
for(i in seq_len(n)){
  v = c(v, i**2)
}
v
```
A better way creates an array of final length first.
```{r}
n = 10
v = numeric(n)
for(i in seq_len(n)) {
  v[i] = i**2
}
v
```

#### Vectorize codes
An even better appraoch is the following. It uses vector operations instead.
```{r}
v = seq_len(n)
v = v*v
v
```

Iteration is commonly used in programming. Unfortunately, iteration, *e.g.*, using a For Loop, is very slow in R. For example, the following code calculates the mean and standard deviation (SD) of a series of numbers. 
``` {r}
my_sum = 0
my_sum2 = 0
num = 100
for (i in seq_len(num)) {
  my_sum = my_sum + i
  my_sum2 = my_sum2 + i*i
}
my_mean = my_sum/num
my_sd = sqrt(my_sum2/num - my_mean**2)
my_mean; my_sd
```
While the above code is typical for C or Fortran, a better approach for R is to use vector operations. 
```{r}
v = seq_len(num)
my_mean = mean(v)
my_variance = mean(v*v)
my_sd = sqrt(my_variance - my_mean**2)
my_mean; my_sd
```
Apply can be used to perform operations for columns (or rows) of a matrix.
```{r}
means = apply(mat, 2, mean)
means2 = apply(mat*mat, 2, mean)
sd = sqrt(means2 - means*means)
sd
```

#### Byte compile package
Any function can be compiled into byte code for an easy performance boost.
```{r}
library(compiler)
my_sd =  function(x) {   # define the function
  my_mean = mean(x)
  my_mean2 = mean(x*x)
  sqrt(my_mean2 - my_mean**2)
}
cmp_sd = cmpfun(my_sd)   # compile it to byte code
cmp_sd(seq_len(100))   # same calculations as a previous example, but with compiled function
apply(mat, 2, cmp_sd)  # apply to a matrix 

```

#### Use C/Fortran codes
Many R packages are written in a compiled language. It is important to use them when possible. It is also feasible to write functions in C, C++, or Fortran, and call these functions from R.
Here is an example of Fortran subroutines, provided in the file "mysub.f90". Note that only integer, double precision and logical arguments are allowed in Fortran-R interface approach. 
```
subroutine cal_sd(n,x,sd)
  integer,intent(in) :: n
  double precision, intent(in) :: x(n)
  double precision, intent(out) :: sd
  integer :: i
  double precision :: mean, mean2
  mean = 0.d0
  mean2 = 0.d0
  do i = 1, n
    mean = mean + x(i)
    mean2 = mean2 + x(i)**2
  end do
  mean = mean/n
  mean2 = mean2/n
  sd = sqrt(mean2 - mean**2)
end subroutine cal_sd
```
The Fortran code needs to be first compiled into a .so file. This needs to be done in command line with a fortran compiler (gfortran from gcc).
```
gfortran -fpic -shared mysub.f90 -o mysub.so
```
Then, in R load the shared library
```{r}
dyn.load("mysub.so")
```
cal_sd can be called in R below. The arguments of the Fortran subroutines can be found in the output list.
```{r}
n = 100
v = seq_len(n)
my_sd = 0.0
results = .Fortran("cal_sd",as.integer(n),as.double(v), my_sd)
results             # [[3]] outputs the sd 
```
To make it even more convenient, one can write a R wrapper.
``` {r}
 my_sd_R <- function(x) {
   if (!is.numeric(x))
           stop("argument x must be numeric")
   my_sd = 0.0
   results =  .Fortran("cal_sd", as.integer(length(x)), as.double(x), my_sd)
   return(results[[3]])
 }
my_sd_R(seq_len(100))
```
More details can be found in [this page](http://users.stat.umn.edu/~geyer/rc/).

#### Parallelization
Lastly, parallelization is another way to improve the performance of R. If simple parallelization is needed, it's pretty simple with Apply functions. Simply setup the desired calculations in a list. Instead of using lapply, use mclapply and specify the number of cores in use. As demonstrated below, the code with parallelization is about three times faster.
```{r}
library(parallel)   # load the parallel library
numCores = detectCores()     # the number of available cores 
tests = seq(1, 10000)
my_test <- function(test_id) {
  v = rnorm(5000)
  return(my_sd_R(v))
}
system.time({      # no parallel
  results = lapply(tests, my_test)
})
system.time({      # with parallel
  results = mclapply(tests, my_test, mc.cores = numCores)
})
```
For additional read, please [check this page](https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html)
